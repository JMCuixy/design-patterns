## 一、剩下的模式  

### 1、桥接模式（Bridge Pattern）

- 概念：不只改变你的实现，也改变你的抽象。桥接模式的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。  
- 角色：  
&emsp;1. 实现类接口（Implementor）：定义行为实现接口。  
&emsp;2. 具体实现类（ConcreteImplementor）：实现 Implementor 接口，提供不同的行为实现。  
&emsp;3. 桥接抽象类（Abstraction）：用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。   
&emsp;4. 扩充抽象类（RefinedAbstraction）：扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。  
- UML图：  
![](https://img2018.cnblogs.com/blog/1153954/201902/1153954-20190213175715135-119471929.png)

- 优点：将抽象与行为实现解耦，二者可以独立扩展，不会影响到对方。  
- 适用场景：当需要使用不同的方式改变接口和实现时。  

### 2、建造者模式（Builder Pattern）

- 概念：封装一个产品的构造过程，并允许按步骤构造。建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。  
- 角色：  
&emsp;1. 抽象建造者（Builder）：给出一个抽象接口，以规范产品对象的各个组成成分的建造。  
&emsp;2. 具体建造者（Concrete Builder）：实现 Builder 角色提供的接口，一步一步完成创建产品实例的过程；在建造过程完成后，提供产品的实例。  
&emsp;3. 指导者（Director）：与客户端打交道，调用具体建造者角色以创建产品对象，指导者并没有产品类的具体知识。  
&emsp;4. 产品（Product）：具体建造者构建的复杂对象。  
- UML图：  
![](https://img2018.cnblogs.com/blog/1153954/201902/1153954-20190214090752090-1738771515.png)

- 优点：  
&emsp;1. 将一个复杂对象的创建过程封装起来；向客户隐藏产品内部的实现。  
&emsp;2. 允许对象通过多个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）。  
&emsp;3. 产品的实现可以被替换，因为客户只看到一个抽象的接口。  
- 建造者模式和模板方法模式的比较区别？  
&emsp;1. 建造者是使用组合方式实现不同的表示，而模板方法使用的是继承的方式。  
&emsp;2. 建造者抽象的是构建过程，而模板方法提取的是实现公共。  

### 3、责任链模式（Chain of Responsibility Pattern）  

- 概念：让一个以上的对象有机会能够处理某个请求。责任链模式为请求创建了一条接收者对象的链，每个接收者都包含对另一个接收者的引用，当某个接受者不能处理该请求时，会将该请求转给下一个接受者处理。  
- 角色：  
&emsp;1. 抽象请求处理者（Handler）：是所有具体请求处理者的父类。  
&emsp;2. 具体请求处理者（Concrete Handler）：实现抽象请求处理者，包含下一个具体请求处理者的引用。
- UML图：  
![](https://img2018.cnblogs.com/blog/1153954/201902/1153954-20190214182534489-595586103.png)

- 优点：  
&emsp;1. 弱化了发出请求的人和处理请求的人之间的关系。发出请求的人只需要向第一个具体的处理者发送请求，然后就可以不用管了，处理者会在责任链上自己寻找处理的方法。  
&emsp;2. 通过改变链内的成员或调动他们的次序，允许你动态地新增或删除责任。   
- 缺点：请求需要在责任链上传播责任，直至找到合适的处理对象。这样虽然提高了程序的灵活性，但同时也出现了处理的延迟。  
- 应用场景：在视窗系统中，经常会使用到责任链模式，尤其是事件的处理，熟悉 javaScript 开发的朋友，可能会知道，浏览器中的事件有冒泡机制，就是事件的是向父控件传播的，如果自己处理不了，就会传播给父控件去处理。  

**<font color="red">tips</font>**：Struts 的拦截器，Servlet 的过滤器，Netty 的 ChannelPipeline 都是责任链模式~  

### 4、蝇量模式（Flyweight Pattern）

- 概念：
- 角色：
- UML：
- 优点：

演示源代码：[<font color=#0000ff>https://github.com/JMCuixy/design-patterns</font>](https://github.com/JMCuixy/design-patterns)

## 二、其他  

### 1、复合模式

- 复合模式：在一个解决方案中结合两个或多个模式，以解决一般或重复发生的问题。  
- MVC 是复合模式，结合了观察者模式、策略模式和组合模式（视图）。这些模式携手合作，把 MVC 模型的三层解耦，这样可以保持设计干净又有弹性。    
- 模型使用观察者模式，以便观察者（视图）更新，同时保持两者之间解耦。  
- 控制器是视图的策略，视图可以使用不同的控制器实现，得到不同的行为。  
- Model 2是 MVC 在 Web 上的应用。  
- 在Model 2中，控制器实现成 Servlet，而 JSP/HTML 是实现视图。  

### 2、设计模式概论

- 模式是在某情境（context）下，针对某问题的某种解决方案。设计模式是解决一个经常重复发生的设计问题。  
- 模式不是法律或准则，模式只是指导方针，你可以改变模式来符合你的需要，真实世界中的许多实例，都不符合经典的设计模式。  
- 请务必牢记在心，模式是被“发现的”，而不是被创建的。所以，任何人都可能发现某个设计模式，然后写出它的描述。  
- 一般来说，必须要通过“三次准则”，才算是一个合格的模式。也就是说，只有在真实世界中被应用三次以上，才能算是一个模式。  
- 根据模式的目标，我们将设计模式分成三个不同的类目：创建型、行为型（对象之间的沟通和互联）和结构型（动态的组合对象）：  
![](https://img2018.cnblogs.com/blog/1153954/201902/1153954-20190213154656045-2015954303.png)  

- 模式只是一种工具，只有在需要时才使用这种工具，而我们时刻要遵守的是模式中的设计原则。  
- 尽可能地用最简单的方式解决问题，不要刻意去使用设计模式！当你在设计的时候，如果确定在你的设计中可以利用某个模式解决某个问题，那么就使用这个模式！如果有更简单的解决方案，那么在决定使用模式之前应该先考虑这个方案。  
- 有一种情况，即使有更简单的解决方案，你仍然想要使用模式，这种情况就是：你预期系统在未来会发生改变，但是务必要确定一件事，这个改变是可能发生的实际改变，而不是假想的改变。  
- 模式可能带来复杂性，可能导致代码被过度工程化，如果没有必要，我们绝不需要这样的复杂性。  

### 3、反模式  

- 反模式告诉你如何采用一个不好的解决方案解决一个问题。虽然反模式看起来总像是一个好的解决方案，但是当它被真正采用后，就会带来麻烦。   
- 反模式的工作内容包括：警告你不要陷入某种致命的诱惑；为何这个解决方案从长远看会造成不同的影响；建议改用其他的模式以提供更好的解决方案。