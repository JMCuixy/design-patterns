## 一、概念  
- 继承的缺点：类数量爆炸、设计死板以及基类加入的新功能可能并不适用于所有的子类。
- 装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。一言以蔽之，动态的扩展类的行为。  
- 角色：  
&emsp;&emsp;1、抽象组件(Component)：给出一个抽象类或接口，以规范准备接收附加责任的行为。  
&emsp;&emsp;2、具体组件(ConcreteComponent)：继承或实现抽象组件，定义一个将要接收附加责任的类。  
&emsp;&emsp;3、抽象装饰者(Decorator)：持有一个组件(Component)对象的实例，一般从抽象组件扩展，类型是抽象类或者接口，目的是达到"类型匹配"。  
&emsp;&emsp;4、具体装饰者(ConcreteDecorator)：继承或实现抽象装饰者，负责给组件对象"贴上"附加的责任。  
## 二、Demo 实现
## 三、总结
- 设计原则：类应该对扩展开放，对修改关闭。
- 特点：  
&emsp;&emsp;1、装饰者和被装饰者对象有相同的超类型。  
&emsp;&emsp;2、你可以用一个或多个装饰者包装一个对象。  
&emsp;&emsp;3、装饰者可以在所委托的被装饰者行为之前或之后，加上自己的行为，以达到特定的目的。  
&emsp;&emsp;4、对象可以在任何时候被装饰，所以你可以在运行时动态地、不限量的用你喜欢的装饰者来装饰对象。  
- 优点：装饰者模式的设计具有弹性，可以应对改变，可以接受新的功能来应对改变的需求。  
- 缺点：如果每个地方都采用开放-封闭原则是一种浪费，也没必要，还会导致代码变得复杂且难以理解。比如会产生很多的小类。