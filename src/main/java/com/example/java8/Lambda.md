## 一、函数接口  

|接口|参数|返回类型|描述|
|:---:|:---:|:---:|:---:|
|Predicate<T>|T|boolean|用来比较操作|
|Consumer<T>|T|void|没有返回值的函数|
|Function<T, R>|T|R|有返回值的函数|
|Supplier<T>|None|T|工厂方法-返回一个对象|
|UnaryOperator<T>|T|T|入参和出参都是相同对象的函数|
|BinaryOperator<T>|(T,T)|T|求两个对象的操作结果|

&emsp;为什么要先从函数接口说起呢？因为我觉得这是 java8 函数式编程的入口呀！每个函数接口都带有 @FunctionalInterface 注释，有且仅有一个未实现的方法，表示接收 Lambda 表达式，它们存在的意义在于将代码块作为数据打包起来。  
&emsp;没有必要过分解读这几个函数接口，完全可以把它们看成普通的接口，不过他们仅有一个抽象方法（因为要接收 Lambda 表达式啊）。  
&emsp;@FunctionalInterface 该注释会强制 javac 检查一个接口是否符合函数接口的标准。 如果该注释添加给一个枚举类型、 类或另一个注释， 或者接口包含不止一个抽象方法， javac 就会报错。  


## 二、Lambda 表达式    
#### 1、Lambda 表达式和匿名内部类    
&emsp;和传入一个实现某接口的对象不同， 我们传入了一段代码块 —— 一个没有名字的函数。event 是参数名， 和上面匿名内部类示例中的是同一个参数。 -> 将参数和 Lambda 表达式的主体分开， 而主体是之后操作会运行的一些代码。

#### 2、Lambda 表达式和集合

## 三、默认方法  

## 四、总结

