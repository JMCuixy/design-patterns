## 一、概念  
- 代理模式：为另一个对象提供一个替身或占位符已控制对这个对象的访问，管理访问的方式有许多种。    
- 角色：   
&emsp;1、Subject：主题接口，为 RealSubject 和 Proxy 提供了接口。通过实现同一接口，Proxy 在 RealSubject 出现的地方的取代它。  
&emsp;2、RealSubject：具体主题，是真正做事的地方，它是被 proxy 代理和控制访问的对象。  
&emsp;3、Proxy：代理对象，持有 RealSubject 的引用，客户和 RealSubject 的交互都必须通过 Proxy。 在某些场景，Proxy 还会负责 RealSubject 对象的创建和销毁。  
![](https://img2018.cnblogs.com/blog/1153954/201901/1153954-20190126212111349-1347202242.jpg)

## 二、代理模式的几种变体  
### 1、远程代理  

&emsp;之前在看《Spring 实战》的时候，接触了[RPC机制](https://www.cnblogs.com/jmcui/p/9044212.html)。现在在读设计模式的时候，才发现 RPC 在设计模式中还有另外一个名字 —— 远程代理。这里就不展开讲了，详细了解，可参考之前的文章。  

### 2、虚拟代理  

### 3、保护代理  




## 三、总结  
- 在真实的世界中，代理模式有许多变体，这些变体都有共通点：都会将客户对主题（Subject）施加的方法调用拦截下来。这种间接的级别让我们可以做很多事，包括将请求分发到远程主题 — 远程代理；给创建开销大的对象提供代表 — 虚拟代理；或者提供某些级别的保护 — 保护代理。
- 除了上面看到的代理模式的变体，代理模式还有很多应用场景：  
&emsp;1、防火墙代理（Firewall Proxy）：控制网络资源的访问，保护主题免于“坏客户”的侵害。  
&emsp;2、智能引用代理（Smart Reference Proxy）：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。  
&emsp;3、缓存代理（Caching Proxy）：为开销大的运算结果提供暂时的存储：它为允许多个客户共享结果，以减少计算和网络延迟。  
&emsp;4、同步代理（Synchronization Proxy）：在多线程的情况下为主题提供安全的访问。  
&emsp;5、复杂隐藏代理（Complexity Hiding Proxy）：用来隐藏一个类的复杂集合的复杂度，并进行访问控制，有时候也被称为外观代理（Facade Proxy）。看起来有点像外观模式，区别在于外观模式只提供了另一组接口，而外观代理控制访问。  
- 如何让客户使用代理，而不是真正的对象？一个常用的技巧是提供一个工厂，实例化并返回主题 — 代理工厂。因为这是在工厂方法内发生的，我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。  
- 装饰者模式为对象增加行为，而代理模式是控制对象的访问。  
- 适配器模式会改变对象适配的接口，而代理模式则实现相同的接口。   
- 优点：  
&emsp;1、代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。    
&emsp;2、代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了保护目标对象的作用。  
- 缺点：  
&emsp;1、由于在客户端和真实对象之间增加了代理对象，请求的链路变长，可能会导致请求速度变慢。  

**<font color="red">tips</font>**：transient 关键字，告诉 jvm 不要序列化这个字段。