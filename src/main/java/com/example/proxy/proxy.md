## 一、概念  
- 代理模式：为另一个对象提供一个替身或占位符已控制对这个对象的访问。  
- 角色：   
&emsp;1、Subject：主题接口，为 RealSubject 和 Proxy 提供了接口。通过实现同一接口，Proxy 在 RealSubject 出现的地方的取代它。  
&emsp;2、RealSubject：具体主题，是真正做事的地方，它是被 proxy 代理和控制访问的对象。  
&emsp;3、Proxy：代理对象，持有 RealSubject 的引用，客户和 RealSubject 的交互都必须通过 Proxy。 在某些场景，Proxy 还会负责 RealSubject 对象的创建和销毁。

![](https://img2018.cnblogs.com/blog/1153954/201901/1153954-20190126212111349-1347202242.jpg)








## 二、代理模式的几种变体




## 三、总结  
- 在真实的世界中，代理模式有许多变体，这些变体都有共通点：都会将客户对主题（Subject）施加的方法调用拦截下来。这种间接的级别让我们可以做很多事，包括将请求分发到远程主题 — 远程代理；给创建开销大的对象提供代表 — 虚拟代理；或者提供某些级别的保护 — 保护代理。
- 除了上面看到的代理模式的变体，代理模式还有很多场景：  
&emsp;1、防火墙代理（Firewall Proxy）：控制网络资源的访问，保护主题免于“坏客户”的侵害。  
&emsp;2、智能引用代理（Smart Reference Proxy）：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。  
&emsp;3、缓存代理（Caching Proxy）：为开销大的运算结果提供暂时的存储：它为允许多个客户共享结果，以减少计算和网络延迟。  
- 如何让客户使用代理，而不是真正的对象？一个常用的技巧是提供一个工厂，实例化并返回主题 — 代理工厂。因为这是在工厂方法内发生的，我们可以用代理包装主题再返回，而客户不知道也不在乎他使用的是代理还是真东西。