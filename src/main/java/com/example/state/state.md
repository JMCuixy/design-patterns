## 一、概念  
- 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。这个模式将状态封装成为独立的类，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态而改变。
- 一个对象“看起来好像修改了它的类”是什么意思呢？从客户的视角来看：如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。然而，实际上，状态模式是在使用组合通过简单引用不同的状态对象来造成类改变的假象。
- 角色：   
&emsp;1、上下文（Context）: 定义客户感兴趣的接口。通常负责具体状态的切换。维护多个 ConcreteState 子类的实例，每个实例分别代表不同的状态。    
&emsp;2、抽象状态类（State）: 定义一个接口或抽象类以封装与 Context 的状态相关的行为。  
&emsp;3、具体状态类（ConcreteState）: 实现 State，实现与 Context 的一个状态相关的行为。每个 ConcreteState 都表示 Context 的一个状态。   
  
![](https://img2018.cnblogs.com/blog/1153954/201901/1153954-20190114092307139-965922926.png)

## 二、Demo 实现



## 三、总结  
- 状态模式允许一个对象基于内部状态而拥有不同的行为。  
- 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化了,便于扩展和理解。  
- 客户不会直接改变 Context 的状态。全盘了解状态是 Context 的工作。Context 会将行为委托给当前状态对象。  
- 状态类可以被多个 Context 实例共享。  
- 基本常识：策略模式和状态模式时双胞胎（它们有相同的类图），在出生时才分开（它们的意图不同）。策略模式和状态模式有什么区别呢？  
&emsp;1、以状态模式而言，我们将一群行为封装在状态对象中，Context 的行为可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出 Context 内部的状态，因此， Context 的行为也会跟着改变。  
&emsp;2、以策略模式而言，客户通常主动指定 Context 所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够运行时改变策略，但对于某个 Context 对象来说，通常都只有一个最适合的策略对象。  
&emsp;3、一般来说，我们把状态模式想成是不用在 Context 中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过在 Context 内简单的改变状态对象来改变 Context 的行为。  
&emsp;4、一般来说，我们将策略模式想成是除了继承之外的一种弹性替代方案。有了策略模式，我们可以通过组合不同的对象来改变行为。  
- 使用状态模式通常会导致设计中类的数目大量增加。（这几乎是所有设计模式的通病）